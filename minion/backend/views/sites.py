#!/usr/bin/env python

import calendar
import datetime
import re
import uuid
from flask import jsonify, request

from minion.backend.app import app
from minion.backend.views.base import _check_required_fields, api_guard, groups, sites
from minion.backend.views.groups import _check_group_exists
from minion.backend.views.plans import _check_plan_exists

def _check_site_url(url):
    regex = re.compile(r"^(http|https)://(localhost|([a-z0-9][-a-z0-9]+)(\.[a-z0-9][-a-z0-9]+)+)(:\d+)?$")
    return regex.match(url) is not None

#def _check_required_fields(expected, fields):
#    for field in fields:
#        if field not in expected:
#            return False
#    return True

def _find_groups_for_site(site):
    """Find all the groups the site is part of"""
    return [g['name'] for g in groups.find({"sites":site})]

def sanitize_site(site):
    if '_id' in site:
        del site['_id']
    if 'created' in site:
        site['created'] = calendar.timegm(site['created'].utctimetuple())
    return site

# API Methods to manage sites

#
# Expects a site id to GET:
#
#  GET /sites/b263bdc6-8692-4ace-aa8b-922b9ec0fc37
#
# Returns the site record:
#
#  { 'success': True,
#    'site': { 'id': 'b263bdc6-8692-4ace-aa8b-922b9ec0fc37',
#              'url': 'https://www.mozilla.com',
#              'groups': ['mozilla', 'key-initiatives'] } }
#
# The groups list is not part of the site but is generated by querying the groups records.
#
# Or returns an error:
#
#  { 'success': False, 'reason': 'site-already-exists' }
#
#

@app.route('/sites/<site_id>', methods=['GET'])
@api_guard
def get_site(site_id):
    site = sites.find_one({'id': site_id})
    if not site:
        return jsonify(success=False, reason='no-such-site')
    site['groups'] = _find_groups_for_site(site['url'])
    return jsonify(success=True, site=sanitize_site(site))

#
# Expects a partially filled out site as POST data:
#
#  POST /sites
#
#  { 'url': 'https://www.mozilla.com',
#    'plans': ['basic', 'nmap'],
#    'groups': ['mozilla', 'key-initiatives'] }
#
# Returns the full site record including the generated id:
#
#  { 'success': True,
#    'site': { 'id': 'b263bdc6-8692-4ace-aa8b-922b9ec0fc37',
#              'url': 'https://www.mozilla.com',
#              'plans': ['basic', 'nmap'],
#              'groups': ['mozilla', 'key-initiatives'] } }
#
# Or returns an error:
#
#  { 'success': False, 'reason': 'site-already-exists' }
#  { 'success': False, 'reason': 'Group xyz does not exist' }
#

@app.route('/sites', methods=['POST'])
@api_guard('application/json')
def create_site():
    site = request.json
    # Verify incoming site: url must be valid, groups must exist, plans must exist
    if not _check_site_url(site.get('url')):
        return jsonify(success=False, reason='invalid-url')
    if not _check_required_fields(site, ['url']):
        return jsonify(success=False, reason='missing-required-field')
    for group in site.get('groups', []):
        if not _check_group_exists(group):
            return jsonify(success=False, reason='unknown-group')
    for plan_name in site.get('plans', []):
        if not _check_plan_exists(plan_name):
            return jsonify(success=False, reason='unknown-plan')
    if sites.find_one({'url': site['url']}) is not None:
        return jsonify(success=False, reason='site-already-exists')
    # Create the site
    new_site = { 'id': str(uuid.uuid4()),
                 'url':  site['url'],
                 'plans': site.get('plans', []),
                 'created': datetime.datetime.utcnow() }
    sites.insert(new_site)
    # Add the site to the groups - group membership is stored in the group object, not in the site
    for group_name in site.get('groups', []):
        # No need to check if the site is already in the group as we just added the site
        groups.update({'name':group_name},{'$addToSet': {'sites': site['url']}})
    new_site['groups'] = site.get('groups', [])
    # Return the new site
    return jsonify(success=True, site=sanitize_site(new_site))

#
# Expects a partially filled out site as POST data. The site with the
# specified site_id (in the URL) will be updated.
#
# It is not possible to change the url. For that you need to delete the
# site and create a new one.
#
#  POST /sites/<site_id>
#
#  { 'url': 'https://www.mozilla.com',
#    'plans': ['basic', 'nmap'],
#    'groups': ['mozilla', 'key-initiatives'] }
#
# Returns the full site record including the generated id:
#
#  { 'success': True,
#    'site': { 'id': 'b263bdc6-8692-4ace-aa8b-922b9ec0fc37',
#              'url': 'https://www.mozilla.com',
#              'plans': ['basic', 'nmap'],
#              'groups': ['mozilla', 'key-initiatives'] } }
#
# Or returns an error:
#
#  { 'success': False, 'reason': 'no-such-site' }
#  { 'success': False, 'reason': 'unknown-group' }
#  { 'success': False, 'reason': 'unknown-plan' }
#

@app.route('/sites/<site_id>', methods=['POST'])
@api_guard
def update_site(site_id):
    new_site = request.json
    site = sites.find_one({'id': site_id})
    if not site:
        return jsonify(success=False, reason='no-such-site')
    for group in new_site.get('groups', []):
        if not _check_group_exists(group):
            return jsonify(success=False, reason='unknown-group')
    for plan_name in new_site.get('plans', []):
        if not _check_plan_exists(plan_name):
            return jsonify(success=False, reason='unknown-plan')

    # we assume there is an old url (even if the url is the same...)
    if 'groups' in new_site:
        # Find all the groups the site is in (potentially an old url)
        # 'groups' in new_site is a list of sites selected
        site_groups = _find_groups_for_site(site['url'])
        new_groups = set(new_site['groups']).difference(site_groups)
        old_groups = set(site_groups).difference(new_site['groups'])
        # Add new groups
        for group_name in new_groups:
            groups.update({'name':group_name}, \
                {'$addToSet': {'sites': site['url']}})
        # Remove old groups
        for group_name in old_groups:
            groups.update({'name':group_name}, \
                {'$pull': {'sites': site['url']}})
    # Modify groups to adopt the new url if there is one
    if new_site.get('url') and new_site['url'] != site['url']:
        groups.update({'sites': site['url']}, \
            {'$set': {'sites.$': new_site['url']}}, \
             upsert=False, multi=True)

    # update plans and url if necessary
    updates = {}
    if new_site.get('url') and new_site['url'] != site['url']:
        updates.update({'url': new_site['url']})
    if 'plans' in new_site:
        updates.update({'plans': new_site['plans']})
    if updates:
        sites.update({'id': site_id}, {'$set': updates})
        site = sites.find_one({'id': site_id})
    # exports updated group info
    site['groups'] = _find_groups_for_site(site['url'])
    return jsonify(success=True, site=sanitize_site(site))

#
# Retrieve all sites in minion
#
#  GET /sites
#
# Returns a list of sites
#
#  [{ 'id': 'b263bdc6-8692-4ace-aa8b-922b9ec0fc37',
#     'url': 'https://www.mozilla.com',
#     'groups': ['mozilla', 'key-initiatives'] },
#    ...]
#

@app.route('/sites', methods=['GET'])
@api_guard
def list_sites():
    sitez = [sanitize_site(site) for site in sites.find()]
    for site in sitez:
        site['groups'] = _find_groups_for_site(site['url'])
    return jsonify(success=True, sites=sitez)

